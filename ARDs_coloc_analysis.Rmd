---
title: "Colocalisation/overlap analysis for age-related diseases (ARDs)"
output: html_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(arrow)
library(data.table)  # got some giant dataframes
library(googlesheets4)
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

```

### Colocalisation/overlap analysis for age-related diseases (ARDs)

I got this data using the Open Targets Platform and Genetics data downloads and PySpark by doing the following:

1. Get all the targets with genetic association with the ARDs
2. Get all the GWAS studies contributing to that evidence
3. Get all *lead* variants from those GWAS studies
4. For these variants, get all colocalisation signals with h4>=0.8 and pval< 5e-8 (`coloc`)
5. For these variants, get all overlapping variants (`overlap`)


#### Data 

In OT Platform, they use `n_initial` from OT Genetics as the `studySampleSize`, so that's what I'll use. 

```{r}
min_n_cases = 2000    ## min n cases for case control studies
min_n_initial = 2000  ## min sample size for continuous traits

diseases <- read.csv("data/full_disease_list.csv")

### All lead variant data for ARDs
ard_leads_all <- arrow::read_parquet("data/targetage/ard_leads.parquet/part-00000-847cd340-cf61-47da-a25d-9d36d195ef39-c000.snappy.parquet")
ard_leads <- filter(ard_leads_all, (n_cases >= min_n_cases) | (is.na(n_cases) & n_initial >= min_n_cases))
#save(ard_leads, file = "ard_leads_filtered.Rda")

### Colocalisation data 
coloc <- arrow::read_parquet("data/targetage/coloc_ard_leads.parquet/part-00000-7408f34e-85ab-43bb-a12f-f5e78b7d314d-c000.snappy.parquet", as_tibble=TRUE)

### Overlap data
overlap <- arrow::read_parquet("data/targetage/overlap_ard_leads.parquet/part-00000-968f5e84-1221-4b35-8a99-69fccda34afb-c000.snappy.parquet",as_data_frame = TRUE)

overlap <- overlap %>% 
  filter((n_cases >= min_n_cases) | (is.na(n_cases) & n_initial >= min_n_cases)) %>%
  filter((right_n_cases >= min_n_cases) | (is.na(right_n_cases) & right_n_initial >= min_n_cases)) %>%
  filter(!is.na(right_is_lead)) %>% ## one variant is NA for this: GCST006288 11_86942946_G_A
  as.data.table() 

## All the colocalisation where the right hand variant is the lead variant (so we have one node per associated locus)
lead_coloc <- coloc %>% filter(right_is_lead == TRUE) 

## All the colocalisation hits where the right hand study is an xQTL study, for later
qtl_coloc <- coloc %>% filter(right_type %in% c("eqtl", "pqtl"))

## All the hits within the ARDs (i.e. both studies are for ARDs)
coloc_within <- lead_coloc %>% filter(!is.na(right_morbidity)) %>% 
  filter((n_cases >= min_n_cases) | (is.na(n_cases) & n_initial >= min_n_cases)) %>%
    filter((right_n_cases >= min_n_cases) | (is.na(right_n_cases) & right_n_initial >= min_n_cases))
overlap_within <- overlap[!is.na(right_morbidity)] %>% as.data.frame()

## All the hits with traits other than our ARDs of interest
coloc_without <- lead_coloc %>% filter(is.na(right_morbidity)) %>% 
  filter((n_cases >= min_n_cases) | (is.na(n_cases) & n_initial >= min_n_cases)) %>%
    filter((right_n_cases >= min_n_cases) | (is.na(right_n_cases) & right_n_initial >= min_n_cases))
overlap_without <- overlap[is.na(right_morbidity)] %>% as.data.frame()

## Overlap/LD where both have sumstats
overlap_within_sumstats <- overlap_within %>% filter(has_sumstats == TRUE & right_has_sumstats == TRUE)
overlap_within_nosumstats <- overlap_within %>% filter(has_sumstats == FALSE | right_has_sumstats == FALSE)

## Target details
targets <- arrow::read_parquet("data/targetage/ard_annotations.parquet/part-00000-2d7e85c7-0644-4728-9921-dbdf119c427d-c000.snappy.parquet", as_tibble=TRUE)

```

#### Some background 

This includes a total of `sum(gwas_tbl$n_gwas_studies)` GWAS studies `nrow(specific_gwas_tbl)` different traits from `nrow(gwas_tbl)` high-level categories. 

The list of ARDs, number of GWAS studies, and number of (lead) variants;

```{r echo=FALSE}
ard_leads %>% group_by(morbidity, studyId) %>% summarise(n_variants = length(studyId)) %>% ungroup() %>% group_by(morbidity) %>% summarise(n_gwas_studies = length(morbidity), n_variants = sum(n_variants)) %>% knitr::kable()

```

The vast majority of studies don't have summary statistics:

```{r, echo = FALSE}
ard_leads_all %>% select(morbidity, studyId, has_sumstats) %>% group_by(morbidity) %>% mutate(n=length(unique(studyId))) %>% unique() %>% ggplot(., aes(y=reorder(morbidity, n))) + geom_bar(aes(fill=has_sumstats)) + theme_bw() + labs(x="Number of GWAS studies") + geom_text(data = . %>% select(morbidity, n) %>% unique(), aes(label = n, x = n), hjust = 0, nudge_x = 5) + theme(panel.grid.minor = element_blank(), panel.grid.major.y = element_blank(), axis.title.y = element_blank())
```

How many studies are we excluding:

```{r, echo = FALSE}

ard_leads_all %>% 
  select(studyId, morbidity, n_cases) %>% 
  unique() %>% 
  group_by(morbidity) %>% 
  mutate(max = max(n_cases, na.rm = TRUE)) %>% 
  ggplot(., aes(x =n_cases, y = reorder(morbidity, max))) + 
    geom_vline(xintercept = 2000, colour = "orange") + 
    geom_boxplot() + 
    theme_bw() + 
    theme(panel.grid.major.y = element_blank(),
          axis.title.y = element_blank())

ard_leads_all %>% 
  select(studyId, morbidity, n_cases) %>% 
  unique() %>% 
  ggplot(., aes(y = morbidity, fill = n_cases >= 2000)) + 
  geom_bar() + 
  theme_bw() + 
  theme(panel.grid.minor = element_blank(),
        panel.grid.major.y = element_blank(),
        axis.title.y = element_blank())

```

Should we use a tag variant number or jaccard index cutoff?

What is the distribution of overlapping variants?

Some leads have > 1000 tagged variants with only a small fraction overlapping

Eg https://genetics.opentargets.org/study/GCST007091 17_45961419_A_G (LD set size according to the portal is 3075, here it is 3146)

```{r}

tags_pairs <- overlap_within %>% 
  select(studyId, lead_variantId, right_studyId, right_variantId, LR_overlap, lead_distinct, right_distinct, has_sumstats) %>% 
  unique() %>% 
  mutate(lead_total = lead_distinct + LR_overlap,
         right_total = right_distinct + LR_overlap,
         jaccard = LR_overlap / (lead_distinct + right_distinct + LR_overlap)) 

tags_pairs %>% 
    select(-lead_distinct, -right_distinct) %>% 
     pivot_longer(-c("morbidity", "has_sumstats")) %>%
     ggplot(., aes(x = value, colour = has_sumstats)) + geom_density() + facet_wrap(~name, scales = "free") + theme_bw()



sapply(tags_pairs, summary)

coloc_within_pairs <-  coloc_within %>%
  select(studyId, lead_variantId, right_studyId, right_variantId, coloc_h4) %>% 
  unique() 

coloc_vs_tag_overlap <- full_join(tags_pairs, coloc_within_pairs) 

coloc_vs_tag_overlap_scan <- coloc_vs_tag_overlap %>% 
  uncount(11, .id = "min_jaccard") %>% 
  mutate(min_jaccard = (1/10)* (min_jaccard - 1)) %>%
  mutate(LD_edge = jaccard >= min_jaccard, coloc_edge = !is.na(coloc_h4)) %>% 
  mutate(coloc_edge = ifelse(has_sumstats == TRUE, coloc_edge, NA))

coloc_vs_tag_overlap_scan_long <- coloc_vs_tag_overlap_scan %>% pivot_longer(c("LD_edge", "coloc_edge"))

ggplot(coloc_vs_tag_overlap_scan_long, aes(x=name, fill = value)) + geom_bar() + facet_grid(has_sumstats ~ min_jaccard) + theme_bw()
  
ggplot(subset(coloc_vs_tag_overlap_scan, has_sumstats == TRUE), aes(x = min_jaccard, fill = LD_edge == coloc_edge)) + geom_bar()+ theme_bw()
coloc_vs_tag_overlap_scan %>% filter(has_sumstats==TRUE, LD_edge == TRUE) %>% ggplot(., aes(x = min_jaccard, fill = LD_edge == coloc_edge)) + geom_bar() + theme_bw()

```

TODO: Can we determine how much extra information colocalisation gives us compared to overlap, when we have full summary statistics? I.e. does it add any or discard any that we would have considered overlapping anyway?

```{r}

tag_variants_ss <- overlap_within %>% filter(has_sumstats == TRUE) ## this is actually finemapping, not LD, as there is SS

```


```{r}

coloc_edges <- g_all$coloc_edges
ld_edges <- g_all$edges
ss_studies <- ard_leads %>% mutate(studyId = paste0(studyId, ".", lead_variantId)) %>% select(studyId, has_sumstats) %>% unique()
ldj <- ld_edges %>% left_join(ss_studies %>% select(from = studyId, from_has_sumstats = has_sumstats)) %>% left_join(ss_studies %>% select(to = studyId, to_has_sumstats = has_sumstats))
colocj <- coloc_edges %>% left_join(ss_studies %>% select(from = studyId, from_has_sumstats = has_sumstats)) %>% left_join(ss_studies %>% select(to = studyId, to_has_sumstats = has_sumstats))
ld_ss <- ldj %>% select(-color, -from_has_sumstats, -to_has_sumstats) %>% mutate(LD = TRUE)
coloc_ss <- colocj %>% select(-color, -from_has_sumstats, -to_has_sumstats) %>% mutate(coloc_ss = TRUE)
tmp <- full_join(coloc_ss, ld_ss)
tmp %>% count(morbidity, coloc_ss, LD) %>% View()
tmp %>% count(coloc_ss, LD)

```


#### Graphs 

Make a graph to visualise the variants and to determine the number of independent genetic signals (i.e. number of disconnected communities) for each ARD. Then we can determine the extent of overlap between ARDs - how many signals are shared compared to the total number of signals. 


```{r}
library(visNetwork)
library(igraph)

## Just to get nice colours
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

## Makes the graph for a given ARD(s)
gwas_graph <- function(curr_morbidities,curr_variants,curr_coloc,curr_overlap, min_jaccard = 0, plot = TRUE) {
  
  g <- list()
  
  # Different colours for ARDs
  g$colours <-
    data.frame(color = gg_color_hue(length(curr_morbidities)), morbidity = curr_morbidities)
  # Get variants and overlaps just for the ARD(s) of interest
  m_variants <- curr_variants %>% filter(morbidity %in% curr_morbidities)
  m_overlap <-
    curr_overlap %>% filter(morbidity %in% curr_morbidities &
                         right_morbidity %in% curr_morbidities)
  m_coloc <-
    curr_coloc %>% filter(morbidity %in% curr_morbidities &
                       right_morbidity %in% curr_morbidities)
  
  # Edges: where two studyId+variantId have at least one overlapping tag variant
  g$edges <-
    m_overlap %>%
    filter((LR_overlap / (right_distinct + lead_distinct + LR_overlap)) >= min_jaccard) %>% 
    mutate(
      from = paste(studyId, lead_variantId, sep = "."),
      to = paste(right_studyId, right_variantId, sep = ".")
    ) %>%
    filter(from != to) %>%
    mutate(dashes = ifelse(has_sumstats == TRUE & right_has_sumstats, TRUE, FALSE)) %>%
    select(from, to, morbidity, dashes) %>%
    left_join(g$colours, by = "morbidity") 
  

  # Edges: where two studyId+variantId are colocalised (edges in black)
  g$coloc_edges <-
    m_coloc %>%
    mutate(
      from = paste(studyId, lead_variantId, sep = "."),
      to = paste(right_studyId, right_variantId, sep = ".")
    ) %>%
    filter(from != to) %>%
    select(from, to, morbidity) %>%
    mutate(color = "black", dashes = FALSE)
  
  # Each node is a studyId+variantId
  # Make a label with the variant, reported trait, and n_cases
  g$nodes <- m_variants %>%
    mutate(id = paste(studyId, lead_variantId, sep = ".")) %>%
    select(id,
           studyId,
           lead_variantId,
           morbidity,
           has_sumstats,
           n_cases,
           trait_reported,
           direction) %>%
    unique() %>%
    left_join(g$colours, by = "morbidity") %>%
    mutate(label = paste0(lead_variantId, "\n", trait_reported, " (", n_cases, ") ", direction)) %>%
    group_by(id) %>%
    mutate(n=length(morbidity)) %>% 
    mutate(morbidity = paste0(morbidity, collapse="+")) %>%
    mutate(color = ifelse(n==1, color, "black")) %>%
 #   mutate(borderDashes = ifelse(direction == "+", FALSE, TRUE)) %>% 
    slice(1) %>%
    select(-n)
  
  if (plot){
      # Make the plot
  g$plot <-
    visNetwork(
      g$nodes,
      bind_rows(g$edges, g$coloc_edges),
      main = curr_morbidities,
      height = "1000px",
      width = "100%"
    ) %>% 
    visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
    visIgraphLayout()
  }

  
  return(g)
  
}

```


Example graphs:

```{r}

graph <- gwas_graph(c("alzheimers disease", "age-related macular degeneration"), ard_leads, coloc_within, overlap_within)
graph <- gwas_graph(c("type 2 diabetes"), ard_leads, coloc_within, overlap_within)
graph <- gwas_graph(c("osteoarthritis", "chronic pain"), ard_leads, coloc_within, overlap_within)

graph

#visSave(graph$plot, "ad_md_graph.html", selfcontained = TRUE, background = "white")
graph <- gwas_graph(d[5:6], ard_leads, coloc_within, overlap_within)


```

Community detection:

```{r}

d <- ard_leads$morbidity %>% unique()

count_communities <- function(curr_morbidities, detect_subgraph_communities = FALSE, ...) {
  ## get relevant edges and nodes
  g <- gwas_graph(curr_morbidities, ...)
  if (nrow(g$edges) > 0) {
    ## make an igraph object
    g$ig <- graph_from_data_frame(
      #bind_rows(g$edges, g$coloc_edges),
                                       bind_rows(
                                          subset(g$edges, dashes == FALSE),  ## overlap edges one or both studies don't have sumstats
                                          g$coloc_edges),                    ## colocalisation edges otherwise (both have sumstats)
                                  directed = FALSE)
    ## get clusters
    clusters <- clusters(g$ig)
    overall_communities <- cluster_louvain(g$ig, weights = NA)
    V(g$ig)$cluster <- clusters$membership
    V(g$ig)$overall_community <- overall_communities$membership
    
    # detect communities in connected component subgraphs
    if (detect_subgraph_communities == TRUE){
            V(g$ig)$community = 0
      for (component in unique(clusters$membership)) {
        g_component_subgraph <-
          induced_subgraph(g$ig, which(clusters$membership == component))
        m <- cluster_louvain(g_component_subgraph)
        V(g$ig)[V(g_component_subgraph)$name]$community = m$membership + max(V(g$ig)$community)
      }
    }

      
          ## add cluster ID, cluster size, and n_morbidities to nodes dataframe
    n <- get.data.frame(g$ig, what = "vertices")
    g$cn <- g$nodes %>%
      left_join(n, by = c("id" = "name")) %>%
      group_by(cluster) %>%
      mutate(c_size = ifelse(is.na(cluster), NA, length(id)),
             n_morbidities = length(unique(morbidity)))
    g$clusters <-
      g$cn %>% group_by(cluster, n_morbidities, morbidity) %>% count() %>% pivot_wider(names_from = "morbidity", values_from = n)
    if (length(curr_morbidities) == 2) {
      ## remove nodes with both morbidity
      ## get number of nodes for each morbidity in each cluster
      tmp <-
        g$cn %>% filter(str_detect(morbidity, "\\+", negate = TRUE)) %>% group_by(cluster, n_morbidities, morbidity) %>% count()
      ## how many nodes aren't in a cluster i.e. don't overlap with any other nodes (i.e. unreplicated) for each morbidity
      singles <-
        tmp %>% ungroup() %>% filter(is.na(cluster)) %>% select(morbidity, single = n)
      ## for clusters, how many consist of just one morbidity (distinct) and how many contain both (shared)
      shared <- tmp %>%
        filter(!is.na(cluster)) %>% # remove single nodes (accounted for in `singles` above)
        select(-n) %>%
        mutate(n_morbidities = ifelse(n_morbidities > 1, 2, n_morbidities)) %>% # clusters with more than 2 morbidities include nodes from GWAS studies involving both morbidity A and B together, so treat these as 2 (i.e. `shared`)
        group_by(morbidity, n_morbidities) %>%
        count() %>%
        mutate(n_morbidities = recode(n_morbidities, `1` = "distinct", `2` = "shared")) %>% pivot_wider(names_from = n_morbidities, values_from = n) %>%
        full_join(singles)
      if (nrow(shared) == 0) {
        shared <-
          data.frame(morbidity = curr_morbidities) %>% mutate(distinct = 0, shared = 0) %>% left_join(singles)
      }
      g$overlap <- shared %>%
        ungroup() %>%
        rename(morbidity_A = morbidity) %>%
        mutate(morbidity_B = rev(.$morbidity_A)) %>%
        inner_join(
          shared %>% rename(morbidity_B = morbidity),
          by = "morbidity_B",
          suffix = c("_A", "_B")
        )
    }
  } else {
    if (length(curr_morbidities) == 2) {
      singles <-
        g$nodes %>% group_by(morbidity) %>% count(name = "single")
      shared <-
        data.frame(morbidity = curr_morbidities) %>% mutate(distinct = 0, shared = 0) %>% left_join(singles)
      g$overlap <- shared %>%
        rename(morbidity_A = morbidity) %>%
        mutate(morbidity_B = rev(.$morbidity_A)) %>%
        inner_join(
          shared %>% rename(morbidity_B = morbidity),
          by = "morbidity_B",
          suffix = c("_A", "_B")
        )
    }
  }
  return(g)
}

####

if (0){
  g_all <- count_communities(d, ard_leads, coloc_within, overlap_within, min_jaccard = 0, detect_subgraph_communities = TRUE, plot = FALSE)
  save(g_all, file = "graph_all_morbidities.Rda")
} else {
  load("graph_all_morbidities.Rda")
}

```


How sensitive should we be - varying jaccard index for edge definition

```{r}

if (0){
  

jaccard_communities_results <- data.frame()

for (curr_min_jaccard in seq(0, 1, 0.1)){
  print(curr_min_jaccard)
  g_jaccard <- count_communities(d, ard_leads, coloc_within, overlap_within, min_jaccard = curr_min_jaccard, detect_subgraph_communities = TRUE, plot = FALSE)
  jaccard_communities_results <- bind_rows(g_jaccard$cn %>% mutate(min_jaccard = curr_min_jaccard), jaccard_communities_results)
}
  save(jaccard_communities_results, file = "jaccard_communities.Rda")
} else {
  load("jaccard_communities.Rda")
}

if(0){
jaccard_communities_results_coloc <- data.frame()

for (curr_min_jaccard in seq(0, 1, 0.1)){
  print(curr_min_jaccard)
  g_jaccard <- count_communities(d, ard_leads, coloc_within, overlap_within, min_jaccard = curr_min_jaccard, detect_subgraph_communities = TRUE, plot = FALSE)
  jaccard_communities_results_coloc <- bind_rows(g_jaccard$cn %>% mutate(min_jaccard = curr_min_jaccard), jaccard_communities_results_coloc)
}
  save(jaccard_communities_results_coloc, file = "jaccard_communities_coloc.Rda")
} else {
  load("jaccard_communities_coloc.Rda")
}
  
jaccard_communities_results <- jaccard_communities_results %>% mutate(edges = "finemapping") 
jaccard_communities_results_coloc <- jaccard_communities_results_coloc %>% mutate(edges = "coloc only")
jaccard_communities_results <- bind_rows(jaccard_communities_results, jaccard_communities_results_coloc)

 ji_n_clusters_comp <-  jaccard_communities_results_all  %>% mutate(type = "all") %>% bind_rows(jaccard_communities_results %>% filter(n_morbidities > 1) %>% mutate(type = ">1 morbidity"))  %>% group_by(edges, type, min_jaccard) %>% summarise(n_clusters = length(unique(cluster))) %>% ggplot(., aes(x=min_jaccard, y = n_clusters, colour = edges)) + geom_line() + geom_point() + facet_wrap(~type, labeller = as_labeller(c(`>1 morbidity` = "Clusters with >1 morbidity", `all` = "All clusters"))) + theme_bw() + labs(x = "Jaccard index threshold", y = "Number of disconnected components (clusters)", subtitle = "Number of communities detected with varying overlap stringency")
 
  ji_n_clusters <-  jaccard_communities_results_all  %>% filter(edges == "coloc only") %>% mutate(type = "all") %>% bind_rows(jaccard_communities_results %>% filter(edges == "coloc only", n_morbidities > 1) %>% mutate(type = ">1 morbidity"))  %>% group_by(edges, type, min_jaccard) %>% summarise(n_clusters = length(unique(cluster))) %>% ggplot(., aes(x=min_jaccard, y = n_clusters)) + geom_line() + geom_point() + facet_wrap(~type, labeller = as_labeller(c(`>1 morbidity` = "Clusters with >1 morbidity", `all` = "All clusters"))) + theme_bw() + labs(x = "Jaccard index threshold", y = "Number of disconnected components (clusters)", subtitle = "Number of clusters detected with varying overlap stringency") + theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank()) + scale_x_continuous(breaks = seq(0, 1, 0.2)) + scale_y_continuous(limits = c(0, 3500), expand = c(0, NA)) 

  ji_n_communities <-  jaccard_communities_results %>% 
    filter(edges == "coloc only") %>% 
    mutate(type = "all") %>% 
    bind_rows(jaccard_communities_results %>% 
                filter(n_morbidities > 1, edges == "coloc only") %>% 
                mutate(type = ">1 morbidity")) %>%  
    group_by(edges, type, min_jaccard, cluster) %>% 
    summarise(communities = length(unique(community))) %>% 
    ggplot(., aes(y= as.character(min_jaccard), x = communities)) + 
    geom_boxplot() + 
    theme_bw()  + 
    labs(x = "Number of communities per disconnected component (cluster)", y = "Jaccard index threshold", subtitle = "Number of communities detected in each cluster with varying overlap stringency") +
    facet_wrap(~type, labeller = as_labeller(c(`>1 morbidity` = "Clusters with >1 morbidity", `all` = "All clusters"))) + 
    theme(panel.grid.minor = element_blank(), panel.grid.major = element_blank()) + scale_x_continuous(breaks = seq(2,10,2))
  
  ji_si_figure <- ji_n_clusters / ji_n_communities + plot_annotation(tag_levels = 'a')
  
  ggsave(ji_si_figure, file = "si_jaccard_index.png", width = 8, height = 7.5, dpi = 300)
  
  chosen <- jaccard_communities_results %>% filter(edges == "coloc only", min_jaccard == 0)
  
  N_clusters_with_communities <- chosen %>% 
    mutate(type = "all") %>% 
    bind_rows(chosen %>% filter(n_morbidities > 1) %>% mutate(type = ">1 morbidity")) %>% 
    group_by(type, cluster) %>% 
    summarise(communities = length(unique(community))) %>% 
    ungroup() %>% 
    group_by(type,communities) %>% 
    count() %>% 
    ungroup() %>% 
    group_by(type) %>% 
    mutate(total = sum(n), proportion = round((n/total)*100,2))
```
There are `length(unique(g_all$cn$cluster))` clusters, and `sum(is.na(g_all$cn$cluster))` nodes are not in a cluster (i.e. not replicated in another study). 

`length(unique(filter(g_all$cn, n_morbidities>1)$cluster))` clusters involve more than one morbidity.

Largest cluster has `max(g_all$cn$c_size, na.rm = TRUE)` nodes and includes `unique(filter(g_all$cn, c_size == max(g_all$cn$c_size, na.rm = TRUE))$morbidity)`

How many nodes are in each cluster, and how many morbidities?

```{r}
cluster_attributes <- g_all$cn %>% filter(!is.na(cluster)) %>% select(cluster, c_size, n_morbidities) %>% unique() %>% pivot_longer(-cluster, names_to = "attribute", values_to = "n") 

ggplot(cluster_attributes, aes(x=n, fill = attribute)) + geom_histogram(binwidth = 1) + facet_wrap(~attribute, nrow = 2, scales = "free") + theme_bw() + guides(fill = FALSE)

ggplot(cluster_attributes, aes(x=n)) + geom_boxplot() + facet_wrap(~attribute, nrow = 2, scales = "free_x") + theme_bw() + guides(fill = FALSE)

g_all$cn %>% filter(!is.na(cluster)) %>% select(cluster, c_size, n_morbidities) %>% unique() %>% ggplot(., aes(x=c_size, y=n_morbidities)) + geom_point(alpha=0.7) + theme_bw()

g_all$clusters 
```

Looking at diseases individually:

```{r}

if (1) {
  individual_graphs <- list()
individual_communities <- data.frame()

for (i in seq_along(d)){
  individual_graphs[[i]] <- count_communities(d[i], ard_leads, coloc_within, overlap_within, plot = FALSE)
  if (nrow(individual_graphs[[i]]$edges)>0){
      ## get number of nodes in each cluster
      replicated <- sum(!is.na(unique(individual_graphs[[i]]$cn$cluster)))
      # how many nodes aren't in a cluster i.e. don't overlap with any other nodes (i.e. unreplicated) 
      singles <-  individual_graphs[[i]]$cn %>% filter(is.na(cluster)) %>% nrow()
      ## for clusters, how many consist of just one morbidity (distinct) and how many contain both (shared)
  } else {
    replicated <- 0
    singles <- nrow(individual_graphs[[i]]$nodes)
  }
  individual_communities <- individual_communities %>% bind_rows(data.frame(morbidity = d[i], replicated = replicated, single = singles, total = replicated + singles))
}
save(individual_graphs, file = "individual_disease_graphs.Rda")
save(individual_communities, file = "individual_disease_n_communities.Rda")
} else {
  load("individual_disease_graphs.Rda")
  load("individual_disease_n_communities.Rda")
}

```

The list of ARDs, number of GWAS studies, and number of (lead) variants, proportion with summary statistics, number of communities

```{r echo=FALSE}
if (0){
  study_size <- ard_leads %>% 
    select(diseaseName, 
           studyId, 
           n_cases, 
           n_initial, 
           ancestry_initial, 
           ancestry_replication) %>% 
  group_by(diseaseName) %>% 
  bind_rows(ard_studies %>% 
              select(-diseaseName) %>% 
              unique() %>% 
              mutate(diseaseName = "Total")) %>% 
  summarise_at(.vars = "n_initial", 
               .funs = c("min", "max", "median"))

total_gwas_tbl <- ard_leads %>% 
  select(studyId, lead_variantId, has_sumstats) %>%
  unique() %>%
  group_by(studyId) %>% 
  summarise(has_sumstats = max(has_sumstats), 
            n_variants = length(studyId)) %>% 
  ungroup() %>% 
  summarise(n_gwas_studies = length(studyId), 
            n_variants = sum(n_variants), 
            has_sumstats = sum(has_sumstats)) %>%
  mutate(diseaseName = "Total")

gwas_tbl <- 
  ard_leads %>% 
  group_by(diseaseId, 
           diseaseName, 
           specificDiseaseId, 
           specificDiseaseName, 
           studyId)  %>% 
  summarise(has_sumstats = max(has_sumstats), 
            n_variants = length(studyId)) %>% 
  ungroup() %>% 
  group_by(diseaseId, diseaseName, specificDiseaseId, specificDiseaseName) %>% 
  summarise(n_gwas_studies = length(specificDiseaseName), 
            has_sumstats = max(has_sumstats), 
            n_variants = sum(n_variants))

summarised_gwas_tbl <- 
  gwas_tbl %>% 
  ungroup() %>% 
  group_by(diseaseName) %>% 
  summarise(n_gwas_studies = sum(n_gwas_studies), 
            has_sumstats = sum(has_sumstats), 
            n_variants = sum(n_variants)) %>% 
  bind_rows(total_gwas_tbl) %>% 
  mutate(has_sumstats = paste0(has_sumstats, 
                               " (", 
                               round((has_sumstats/n_gwas_studies)*100), 
                               "%)")) %>% 
  left_join(study_size) %>% 
    full_join(ard_leads %>% 
              select(diseaseName, morbidity) %>% 
              unique()) %>%
  full_join(individual_communities) %>%
  select(-morbidity) %>%
  select(diseaseName, n_gwas_studies, has_sumstats, min, max, median, n_variants, everything())

full_gwas_tbl <- gwas_tbl %>% 
  full_join(diseases) %>% 
  select(-therapeuticAreas) %>%
  filter(!is.na(n_gwas_studies) | diseaseId == specificDiseaseId) %>%
  arrange(diseaseName) 

gs4_create("gwas_table", sheets = summarised_gwas_tbl)
gs4_create("gwas_specific_table", sheets = full_gwas_tbl)
}


```

Studies and ancestry

```{r}
ancestries <- ard_leads %>% select(studyId, ancestry_initial) %>% unique() %>% unnest(ancestry_initial) %>% separate(ancestry_initial, into = c("ancestry", "n"), sep = "=") %>% group_by(studyId) %>% mutate(n = as.numeric(n), total = sum(n), proportion = n/total)

ancestries %>% filter(proportion == 1) %>% ungroup() %>% count(ancestry) %>% mutate(p = n/sum(n)*100)

```


Looking pairwise between diseases:

```{r}


if(0){
combs <- combn(d, 2, simplify = FALSE)
pairwise_graphs <- list()
for (i in seq_along(combs)){
  pairwise_graphs[[i]] <- count_communities(combs[[i]], ard_leads, coloc_within, overlap_within, plot = FALSE)
}
overlaps <- pairwise_graphs %>% purrr::map("overlap")
overlaps_df <- pairwise_graphs %>% purrr::map(8) %>% dplyr::bind_rows()

save(overlaps_df, file = "genetic_overlaps_df.Rda")
save(pairwise_graphs, file = "genetic_overlaps_graphs.Rda")
} else {
  load("genetic_overlaps_df.Rda")
  load("genetic_overlaps_graphs.Rda")
}

```

Now to make a heatmap

```{r}

textcol <- "grey40"

prop_shared <- individual_communities %>% 
  select(morbidity_A = morbidity, total_A = total) %>% 
  full_join(overlaps_df) %>% 
  mutate(proportion_A = shared_A/total_A) %>% 
  select(morbidity_A, morbidity_B, total_A, shared_A, proportion_A)

### making a heatmap
coloc_pre_heatmap <- prop_shared %>% 
  select(-shared_A, -total_A) %>% 
  pivot_wider(names_from = morbidity_A, values_from = proportion_A) %>%  
  replace(is.na(.), 0)

library("ggdendro")

# Run clustering
coloc_mat <- as.matrix(coloc_pre_heatmap[,-1])
rownames(coloc_mat) <- coloc_pre_heatmap$morbidity.y
coloc.dendro <- as.dendrogram(hclust(d = dist(x = coloc_mat)))

# Create dendro
dendro.plot <- ggdendrogram(data = coloc.dendro, rotate = TRUE)

# Preview the plot
print(dendro.plot)

## reorder to the clustered order
coloc.order <- order.dendrogram(coloc.dendro)
                                                                              
coloc_pre_heatmap_long <- coloc_pre_heatmap %>% 
  replace(. == 0, NA) %>%
  pivot_longer(-morbidity_B, names_to = "morbidity_A", values_to = "proportion") %>%
  left_join(prop_shared %>% 
              select(-proportion_A), 
              by = c("morbidity_A", "morbidity_B")) 
             
coloc_pre_heatmap_long$morbidity_B <- factor(x = coloc_pre_heatmap_long$morbidity_B,
                                        levels = coloc_pre_heatmap$morbidity_B[coloc.order],
                                        ordered = TRUE)
coloc_pre_heatmap_long$morbidity_A <- factor(x = coloc_pre_heatmap_long$morbidity_A,
                                        levels = coloc_pre_heatmap$morbidity_B[coloc.order],
                                        ordered = TRUE)

coloc_heatmap <- coloc_pre_heatmap_long %>%
 # mutate_at((c("morbidity_A", "morbidity_B")), str_replace_all, pattern ="chronic obstructive pulmonary disease", replacement = "COPD") %>%
  ggplot(., aes(x=morbidity_A, y = morbidity_B, fill = proportion)) +
  geom_tile(colour = textcol) +
  geom_text(aes(label = shared_A, colour = proportion > 0.45), size = 2.1) + 
  labs(subtitle = "Independent genetic associations shared between\nage-related diseases and traits") +
  coord_fixed() +
  theme_bw(base_size = 10) +
  scale_y_discrete(expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_color_manual(values = c("black", "white"), breaks = c(FALSE, TRUE)) +
  scale_fill_gradient(
    "proportion",
    low = "#CBDEF0",
    high = "#08306B",
    na.value = "white",
    guide = guide_colorbar(frame.colour = "black", frame.linewidth = 0.8)
  ) +
  guides(color = FALSE) + 
  theme(
    axis.text.x = element_text(
      colour = textcol,
      angle = 45,
      hjust = 1
    ),
    axis.text.y = element_text(vjust = 0.2,
                               colour = textcol),
    axis.ticks = element_line(size = 0.4),
    axis.title = element_blank(),
    plot.background = element_blank(),
    plot.margin = margin(0.7, 0.4, 0.1, 0.2, "cm"),
    plot.title = element_text(
      colour = textcol,
      hjust = 0,
      size = 14,
      face = "bold"
    ),
    panel.border = element_rect(colour = "black",
                                size = 0.8)
  )


ggsave(coloc_heatmap, file = "coloc_heatmap.png", width = 8, height = 7.5, dpi = 300)


```



```{r}
## all nodes that are in a cluster
clustered_nodes <- g_all$cn %>% filter(!is.na(cluster))

## nodes in a cluster that includes more than one morbidity
mm_clustered_nodes <- clustered_nodes %>% filter(n_morbidities>1)

view_cluster <- function(nodes, g, curr_cluster){
  cluster_nodes <- nodes %>% filter(cluster %in% curr_cluster)
  cluster_edges <- g$edges %>% 
  filter((from %in% cluster_nodes$id) & (to %in% cluster_nodes$id)) 
  vn <- 
    visNetwork(
      cluster_nodes,
      cluster_edges,
      height = "1000px",
      width = "100%"
    ) %>% 
#    visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
    visIgraphLayout()
  return(vn)
}

view_morbidity <- function(nodes, g, curr_morbidity){
  cluster_nodes <- nodes %>% 
    filter(cluster %in% filter(nodes, morbidity==curr_morbidity)$cluster)
  cluster_edges <- g$edges %>% 
  filter(from %in% cluster_nodes$id) %>%
  filter(to %in% cluster_nodes$id)
  vn <- 
    visNetwork(
      cluster_nodes,
      cluster_edges,
      height = "1000px",
      width = "100%"
    ) %>% 
#    visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
    visIgraphLayout()
  return(vn)
}
  
```

```{r}
library(UpSetR)
mm_mat <- mm_clusters %>% select(cluster, morbidity, n)  %>% pivot_wider(names_from = morbidity, values_from = n, values_fill = list(n=0)) %>% data.frame()

mm_mat2 <- as.matrix(mm_mat[,-1])
rownames(mm_mat2) <- mm_mat$cluster

upset(mm_mat)

mat <- cn %>% filter(!is.na(cluster)) %>% ungroup() %>% select(cluster, morbidity) %>% group_by(cluster, morbidity) %>% count() %>% pivot_wider(names_from = morbidity, values_from = n)
mat[is.na(mat)] <- 0

tmat <- cn %>% filter(!is.na(cluster)) %>% ungroup() %>% select(cluster, morbidity) %>% group_by(cluster, morbidity) %>% count()


cmat <- as.matrix(mat[,-1])
rownames(cmat) <- mat$cluster

```

=======
```{r}
#save(g_all, file = "graph_all_morbidities.Rda")
load("graph_all_morbidities.Rda")

```


Now to link to genes

Q1: Do we use L2G or V2G? L2G
Q2: How do we expand to tag variants? Tag variants depend on the study if using finemapping. Does OT take L2G for tag variants or just lead variants?

```{r}
# studies + variants
studies_variants <- g_all$cn %>% filter(n_morbidities > 1) %>% ungroup() %>% select(studyId, lead_variantId) %>% unique()

if(0) {
library(ghql)
library(jsonlite)

initialise_api <- function(){
  cli <- GraphqlClient$new(
  url = "https://genetics-api.opentargets.io/graphql"
)
  return(cli)
}

initialise_queries <- function(){
    qry <- Query$new()
  qry$query('l2g_query', 'query l2gQuery($studyId: String!, $variantId: String!){
  studyLocus2GeneTable(studyId: $studyId, variantId: $variantId){
    rows {
      gene {
        id
        symbol
      }
      hasColoc
      yProbaModel
      yProbaDistance
      yProbaInteraction
      yProbaMolecularQTL
      yProbaPathogenicity
      distanceToLocus
    }
  }
  variantInfo(variantId: $variantId){
      mostSevereConsequence
  }
}')
  return(qry)
}

## Do the API call
fetch_l2g <- function(df, variables){
  result <- fromJSON(cli$exec(qry$queries$l2g_query, variables, flatten = TRUE))$data

  l2g_result <- result$studyLocus2GeneTable %>% bind_cols(result$variantInfo) %>% bind_cols(df) 
  return(l2g_result)
}

#########

cli <- initialise_api()
qry <- initialise_queries()

## split the data frame into smaller chunks (1000 rows)
## I don't really know if we need to do this but just in case
## I'm scared of breaking the server with too many successive calls

n <- 100
nr <- nrow(studies_variants)
studies_variants_split <-
  studies_variants %>% 
  split(., rep(1:ceiling(nr / n), each = n, length.out = nr))

# Somewhere to hold the results
l2g_all <- vector(mode = "list", length = length(studies_variants_split))

## Do the first chunk on its own to check 
l2g_all[[1]] <-  studies_variants_split[[1]]  %>% 
  group_by(studyId, lead_variantId) %>% 
  group_split() %>% 
  ## API call for each studyID + variantID
  purrr::map(~fetch_l2g(df = ., variables = list(studyId = .$studyId, variantId = .$lead_variantId))) %>%
  bind_rows() 

## Do all the other chunks
for (i in seq(2, length(l2g_all))){
  print(i)
  l2g_all[[i]] <- studies_variants_split[[i]] %>% 
    group_by(studyId, lead_variantId) %>% 
    group_split() %>% 
    ## API call for each studyID + variantID
    purrr::map(~fetch_l2g(df = ., variables = list(studyId = .$studyId, variantId = .$lead_variantId))) %>%
    bind_rows() 
    Sys.sleep(3)
}

l2g_all_joined <- l2g_all %>% bind_rows() %>% jsonlite::flatten() %>% filter(yProbaModel >= 0.05)
save(l2g_all_joined, file="ltg_all.Rda")

} else {
  load("ltg_all.Rda")
}


```


Colocalisation with top L2G gene

```{r}
qtl_to_join <- qtl_coloc %>%
  select(studyId, lead_variantId, right_type, right_studyId, coloc_h4, starts_with("lead_var_right_"), right_phenotype, right_bio_feature, right_gene_id) %>%
  mutate(direction = ifelse(lead_var_right_study_beta > 0, "increased", "decreased")) %>% 
  mutate(trait = ifelse(right_type == "eqtl", "expression", ifelse(right_type == "pqtl", "abundance", NA))) %>% 
  unite(molecular_trait, c(direction, trait), sep = " ", remove = TRUE)

l2g_qtl_coloc <- l2g_all_joined %>% 
  filter(hasColoc == TRUE) %>% 
  left_join(qtl_to_join, c("studyId", "lead_variantId", "gene.id" = "right_gene_id"))

save(l2g_qtl_coloc, file = "TargetAgeGenetics/l2g_qtl_coloc.Rda")


```

Only use genes with >=0.5 L2G score? Or 0.05?

"Prioritised genes" section of GWAS study page on OT genetics shows genes with >=0.5.
Open Targets Platform uses >=0.05 

492 clusters have more than one morbidity.
270 have at least one gene with coloc evidence

```{r}
min_l2g = 0.05
tbl <- g_all$cn %>% group_by(cluster, n_morbidities) %>% summarise(nodes = length(id), morbidities = paste0(unique(morbidity), collapse = ", ")) %>% arrange(-n_morbidities) %>% filter(!is.na(cluster))

all_cluster_genes <- g_all$cn %>% left_join(l2g_all_joined %>% filter(yProbaModel>= min_l2g)) %>% left_join(tbl) %>% filter(n_morbidities>1)

top_l2g <- l2g_all_joined %>%
    group_by(studyId, lead_variantId) %>% 
    top_n(1,yProbaModel )  ## need to remove duplicates for 5 variants 

top_cluster_genes <- g_all$cn %>% left_join(top_l2g %>% filter(yProbaModel>= min_l2g)) %>% left_join(tbl) %>% filter(n_morbidities>1)

top_cluster_genes_summarised <- top_cluster_genes %>% filter(yProbaModel >= 0.5) %>% ungroup() %>% group_by(gene.id, gene.symbol, cluster) %>% count() %>% filter(!is.na(cluster)) %>% ungroup() %>% group_by(gene.id, gene.symbol) %>% summarise(n_clusters = length(cluster)) %>% arrange(-n_clusters)

write.table(top_cluster_genes_summarised, file = "top_L2G_genes.txt", sep = " ", row.names = FALSE, col.names = FALSE, quote = FALSE)

```


```{r}

top_l2g <- l2g_all_joined %>%
    group_by(studyId, lead_variantId) %>% 
    top_n(1,yProbaModel )
top_l2g %>% pivot_longer(contains("yProba")) %>% ggplot(., aes(x=value, y=name)) + geom_boxplot() + theme_bw() + theme(axis.title.y = element_blank(), axis.title.x = element_blank())

```


If we collapse each cluster to a node, we can link to genes and diseases!

```{r}
C2G_edges <- 
  cluster_genes %>% 
  filter(yM)
  select(from = cluster, to = gene.id, morbidity, hasColoc, starts_with("yProba")) %>%
  mutate(type = "L2G") %>%
  unique()

C2D_edges <- 
  cluster_genes %>%
  select(from = cluster, to = morbidity, studyId) %>%
  mutate(type = "GWAS") %>%
  unique()

C_nodes <- cluster_genes %>% select(id = cluster, morbidities, c_size) %>% unique() %>% filter(!is.na(id)) %>% mutate(id = as.character(id), type = "cluster", color = "green")
M_nodes <- cluster_genes %>% ungroup() %>% select(id = morbidity, trait_reported) %>% unique() %>% group_by(id) %>% summarise(traits = paste(trait_reported, collapse = ", ")) %>% mutate(type = "morbidity", color = "red")
G_nodes <- cluster_genes %>% ungroup() %>% select(id = gene.id, gene.symbol) %>% unique() %>% mutate(type = "gene", color = "blue")

cluster_vn <- 
  visNetwork(
    bind_rows(C_nodes, M_nodes, G_nodes),
    bind_rows(C2G_edges, C2D_edges),
    height = "1000px",
    width = "100%"
  ) %>%
    visIgraphLayout()

```

Looking at targets

```{r}
go_terms <- read.csv("data/full_goterm_list.csv")

go <- targets %>% 
  select(targetId, targetSymbol, go) %>% 
  unnest_wider(go) %>% 
  unnest(c(id, value))

reactome <- targets %>% select(targetId, targetSymbol, reactome) %>% unnest(reactome)

interesting_pathways <- data.frame(reactome.term = c("Autophagy", "Cell Cycle", "Cell-Cell communication", "DNA Repair", "Extracellular matrix organization", "Metabolism", "Metabolism of proteins"), reactome.id = c("R-HSA-9612973", "R-HSA-1640170", "R-HSA-1500931", "R-HSA-73894", "R-HSA-1474244", "R-HSA-1430728", "R-HSA-392499" ))



```

